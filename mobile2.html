<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>Comunicador por Mirada (M√≥vil) ‚Äî S√≠ / No / Gracias / Ayuda</title>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh"></script>
<style>
  html,body{margin:0;padding:0;height:100%;background:#0f1115;color:#fff;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial}
  #top{position:fixed;top:0;left:0;right:0;display:flex;gap:8px;padding:10px;align-items:center;background:rgba(0,0,0,.5);z-index:10}
  .btn{appearance:none;border:0;padding:10px 14px;border-radius:12px;cursor:pointer;background:#22272e;color:#fff;font-weight:700;font-size:16px}
  .btn.primary{background:#00e676;color:#111}
  #grid{position:fixed;inset:58px 8px 8px 8px;display:grid;grid-template-columns:1fr 1fr;grid-template-rows:1fr 1fr;gap:8px}
  .cell{display:flex;align-items:center;justify-content:center;border-radius:14px;font-size:clamp(24px,7vw,40px);font-weight:900}
  .cell.focus{outline:3px solid #00e676;box-shadow:0 0 0 6px rgba(0,230,118,.2)}
  .c-si{background:#123421} .c-no{background:#34121a} .c-gracias{background:#122238} .c-ayuda{background:#32250f}
  #cursor{position:fixed;width:18px;height:18px;border:2px solid #fff;border-radius:50%;transform:translate(-50%,-50%);pointer-events:none;display:none;z-index:12}
  #bar{position:fixed;left:50%;bottom:12px;transform:translateX(-50%);width:80%;height:10px;background:#2b2f3a;border-radius:8px;overflow:hidden}
  #fill{height:100%;width:0;background:#00e676}
  #err{position:fixed;left:0;right:0;bottom:0;background:#ff3344;color:#100;padding:6px 10px;font:12px/1.3 monospace;display:none;z-index:20}
</style>
</head>
<body>
<div id="top">
  <button id="start" class="btn primary">üé• Probar c√°mara</button>
  <button id="cal" class="btn">üéØ Calibrar</button>
  <button id="reset" class="btn">‚ôªÔ∏è Reset</button>
</div>
<div id="grid">
  <div class="cell c-si"      data-key="s√≠">S√≠</div>
  <div class="cell c-no"      data-key="no">No</div>
  <div class="cell c-gracias" data-key="gracias">Gracias</div>
  <div class="cell c-ayuda"   data-key="ayuda">Ayuda</div>
</div>
<div id="cursor"></div>
<div id="roi" style="position:fixed;border:2px dashed rgba(0,230,118,.9);border-radius:10px;pointer-events:none;z-index:9;"></div>
<canvas id="preview" style="position:fixed;right:10px;top:70px;width:120px;height:90px;background:#000;border:1px solid rgba(255,255,255,.5);z-index:11;"></canvas>
<div id="bar"><div id="fill"></div></div>
<div id="err"></div>
<div id="debug" style="position:fixed;left:0;top:60px;background:rgba(0,0,0,.7);color:#fff;padding:5px;font:12px monospace;z-index:10;"></div>

<script>
(function(){
  const IS_IOS = /iPad|iPhone|iPod/.test(navigator.userAgent) ||
                 (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);

  // LocalStorage keys
  const LS_CAL = 'mobile_aac_cal';
  const LS_ROI = 'mobile_aac_roi';

  function saveLS(k,v){ try{ if(v==null) localStorage.removeItem(k); else localStorage.setItem(k,JSON.stringify(v)); }catch{} }
  function loadLS(k){ try{ const s=localStorage.getItem(k); return s?JSON.parse(s):null; }catch{ return null; } }

  const CFG = {
    detConf: IS_IOS ? .3 : .5, trackConf:.5,
    refine: true,
    camW: IS_IOS ? 320 : 640, camH: IS_IOS ? 240 : 480, camFps: IS_IOS ? 15 : 30,
    mirrorInput: true,
    invertX:false, invertY:false,
    gainX:0.4, gainY:0.4,
    smoothingFactor: 0.98,
    dwellMs:1200,
    speak:true
  };

  const startBtn = document.getElementById('start');
  const calBtn = document.getElementById('cal');
  const resetBtn = document.getElementById('reset');
  const cells = Array.from(document.querySelectorAll('.cell'));
  const cursor = document.getElementById('cursor');
  const roiBox = document.getElementById('roi');
  const preview = document.getElementById('preview');
  const pctx = preview.getContext('2d');
  const fill = document.getElementById('fill');
  const err = document.getElementById('err');
  const debug = document.getElementById('debug');

  let W=window.innerWidth, H=window.innerHeight;
  let stream=null, video=null, faceMesh=null;
  let irisN={x:null,y:null};
  let smoothedGx = null, smoothedGy = null;
  let A=[W,0,0,H], b=[0,0], hasCal=false;
  let roi={x0:.08,y0:.08,x1:.92,y1:.92};
  let frameCount = 0;
  let lastPx = 0, lastPy = 0;

  function showErr(m){ err.textContent='‚ö†Ô∏è '+m; err.style.display='block'; }
  function pxROI(){ return { x: roi.x0*W, y: roi.y0*H, w:(roi.x1-roi.x0)*W, h:(roi.y1-roi.y0)*H }; }
  function setDefaultAffineFromROI(){
    const R=pxROI(); A=[R.w,0,0,R.h]; b=[R.x,R.y];
    if(!hasCal) drawRoi();
  }
  function drawRoi(){
    const R=pxROI(); roiBox.style.display='block';
    roiBox.style.left=R.x+'px'; roiBox.style.top=R.y+'px';
    roiBox.style.width=R.w+'px'; roiBox.style.height=R.h+'px';
  }
  function hideRoi(){ roiBox.style.display='none'; }
  function resize(){ W=window.innerWidth; H=window.innerHeight; if(!hasCal){ setDefaultAffineFromROI(); } }
  window.addEventListener('resize', resize); resize();
  preview.width = 120; preview.height = 90;
  preview.width = 100; preview.height = 75;

  // Load calibration
  (function(){
    const c = loadLS(LS_CAL);
    if(c && c.A && c.b){ A=c.A; b=c.b; hasCal=true; }
    const r = loadLS(LS_ROI);
    if(r && 'x0' in r){ roi = r; }
  })();

  async function startCamera(){
    startBtn.textContent = 'Cargando...';
    debug.textContent = 'Starting camera...';
    if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){
      showErr('getUserMedia no soportado');
      debug.textContent += ' | getUserMedia not supported';
      startBtn.textContent = 'Probar c√°mara';
      return;
    }
    if(location.protocol !== 'https:' && location.hostname !== 'localhost'){
      showErr('Requiere HTTPS para c√°mara');
      debug.textContent += ' | Not HTTPS';
      startBtn.textContent = 'Probar c√°mara';
      return;
    }
    debug.textContent += ' | Requesting camera...';
    try{
      stream = await navigator.mediaDevices.getUserMedia({
        video:{width:{ideal:CFG.camW},height:{ideal:CFG.camH},frameRate:{ideal:CFG.camFps,max:CFG.camFps},facingMode:'user'},
        audio:false
      });
      debug.textContent += ' | Got stream';
      video=document.createElement('video');
      video.playsInline=true; video.muted=true; video.autoplay=true;
      video.srcObject=stream;
      if(IS_IOS){
        video.style.position='fixed'; video.style.top='0'; video.style.left='0';
        video.style.width='10px'; video.style.height='10px'; video.style.opacity='0.01'; // Minimal but valid for iOS
        document.body.appendChild(video);
        debug.textContent += ' | Video appended';
      }
      await video.play();
      debug.textContent += ' | Video playing';
      err.style.display='none';
      startBtn.textContent = 'C√°mara activa';
      requestAnimationFrame(loop);
    }catch(e){ showErr((e.name||'')+' ‚Äî '+(e.message||e)); debug.textContent += ' | Error: ' + e.message; startBtn.textContent = 'Probar c√°mara'; }
  }
  startBtn.addEventListener('click', startCamera, {once:true});
  startBtn.addEventListener('touchend', (e) => { e.preventDefault(); startCamera(); }, {once:true});

  resetBtn.addEventListener('click', ()=>{ hasCal=false; saveLS(LS_CAL,null); saveLS(LS_ROI,null); setDefaultAffineFromROI(); });

  calBtn.addEventListener('click', async ()=>{
    const pts = [
      {x:0, y:0}, {x:W, y:0}, {x:W, y:H}, {x:0, y:H}, {x:W/2, y:H/2}
    ];
    const src = [], dst = [];
    for(const t of pts){
      const mark = document.createElement('div');
      Object.assign(mark.style, {
        position:'fixed', left:t.x+'px', top:t.y+'px', width:'20px', height:'20px',
        borderRadius:'50%', background:'#00e676', transform:'translate(-50%,-50%)', zIndex:15
      });
      document.body.appendChild(mark);
      await new Promise(res=>{
        const samples = []; const t0 = performance.now();
        (function step(){
          const now = performance.now();
          if(irisN.x != null) samples.push([irisN.x, irisN.y]);
          if(now - t0 < 1500) requestAnimationFrame(step);
          else{
            const m = mean2(samples);
            if(!isNaN(m[0])){ src.push(m); dst.push([t.x, t.y]); }
            document.body.removeChild(mark); res();
          }
        })();
      });
    }
    const sol = lsqAffine(src, dst);
    if(sol){ A = sol.A; b = sol.b; hasCal = true; saveLS(LS_CAL, {A, b}); hideRoi(); }
  });

  faceMesh = new FaceMesh({ locateFile:(f)=>`https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}` });
  faceMesh.setOptions({ maxNumFaces:1, refineLandmarks:CFG.refine, minDetectionConfidence:CFG.detConf, minTrackingConfidence:CFG.trackConf });

  function bboxOf(lm){let minx=1,miny=1,maxx=0,maxy=0; for(const p of lm){minx=Math.min(minx,p.x); miny=Math.min(miny,p.y); maxx=Math.max(maxx,p.x); maxy=Math.max(maxy,p.y);} return {minx,miny,maxx,maxy,cx:(minx+maxx)/2,cy:(miny+maxy)/2,area:(maxx-minx)*(maxy-miny)};}
  function dist2(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
  function avgXY(lm, idxs){ let x=0,y=0; for(const i of idxs){ x+=lm[i].x; y+=lm[i].y; } return {x:x/idxs.length, y:y/idxs.length}; }
  async function loop(){
    if(video && video.readyState>=2){
      await faceMesh.send({image:video});
      debug.textContent = `Loop: ready | ` + debug.textContent;
    } else {
      debug.textContent = `Loop: not ready (${video?.readyState})`;
    }
    requestAnimationFrame(loop);
  }

  // -------- Dwell state --------
  cursor.style.display='block';
  let focusCell=null, t0=0;

  function updateCursor(x,y){
    const px=Math.max(0,Math.min(W-1,x)), py=Math.max(0,Math.min(H-1,y));
    cursor.style.left=px+'px'; cursor.style.top=py+'px';
    const el=document.elementFromPoint(px,py);
    const cell=el&&el.closest?.('.cell');
    if(cell!==focusCell){
      if(focusCell) focusCell.classList.remove('focus');
      focusCell=cell; t0=performance.now(); fill.style.width='0%';
      if(focusCell) focusCell.classList.add('focus');
    }
  }

  function dwellDetect(){
    if(!focusCell) return;
    const f=Math.max(0,Math.min(1,(performance.now()-t0)/CFG.dwellMs));
    fill.style.width=(f*100).toFixed(0)+'%';
    if(f>=1){ selectCell(focusCell); t0=performance.now(); fill.style.width='0%'; }
  }

  function selectCell(cell){
    const key=(cell.dataset.key||cell.textContent.trim()).toLowerCase();
    cell.classList.add('focus'); setTimeout(()=>cell.classList.remove('focus'),300);
    if(CFG.speak && 'speechSynthesis' in window){
      const u=new SpeechSynthesisUtterance(key); u.lang='es-ES'; speechSynthesis.cancel(); speechSynthesis.speak(u);
    }
  }

  faceMesh.onResults(res=>{
    frameCount++;
    debug.textContent = `Frame: ${frameCount} | Faces: ${res.multiFaceLandmarks ? res.multiFaceLandmarks.length : 0}`;
    if(video){
      pctx.clearRect(0,0,preview.width,preview.height);
      pctx.drawImage(video,0,0,preview.width,preview.height);
    }
    if(!res.multiFaceLandmarks||!res.multiFaceLandmarks.length) return;
    const lm=res.multiFaceLandmarks[0];
    const fb=bboxOf(lm); if(fb.area<0.02) return;
    debug.textContent += ` | Area: ${fb.area.toFixed(3)}`;
    // Draw iris dots
    drawDot(lm[468]); drawDot(lm[473]);

    const rC=avgXY(lm,[468,469,470,471]), lC=avgXY(lm,[473,474,475,476]);
    const R_L=lm[33],R_R=lm[133],L_L=lm[362],L_R=lm[263];
    const R_T=lm[159],R_B=lm[145],L_T=lm[386],L_B=lm[374];
    const rW=Math.max(1e-6,Math.abs(R_R.x-R_L.x)), lW=Math.max(1e-6,Math.abs(L_R.x-L_L.x));
    const rH=Math.max(1e-6,Math.abs(R_B.y-R_T.y)), lH=Math.max(1e-6,Math.abs(L_B.y-L_T.y));
    let rx=(rC.x-Math.min(R_L.x,R_R.x))/rW, lx=(lC.x-Math.min(L_L.x,L_R.x))/lW;
    let ry=(rC.y-Math.min(R_T.y,R_B.y))/rH, ly=(lC.y-Math.min(L_T.y,L_B.y))/lH;
    let gxN=cl01((rx+lx)/2), gyN=cl01((ry+ly)/2);
    if(CFG.mirrorInput){ gxN = 1 - gxN; }
    if(CFG.invertX) gxN=1-gxN; if(CFG.invertY) gyN=1-gyN;
    gxN=cl01(0.5+(gxN-0.5)*CFG.gainX); gyN=cl01(0.5+(gyN-0.5)*CFG.gainY);
    irisN.x=gxN; irisN.y=gyN;
    debug.textContent += ` | iris: ${gxN.toFixed(2)},${gyN.toFixed(2)}`;

    // Suavizado exponencial
    if (smoothedGx === null) smoothedGx = gxN; else smoothedGx = CFG.smoothingFactor * smoothedGx + (1 - CFG.smoothingFactor) * gxN;
    if (smoothedGy === null) smoothedGy = gyN; else smoothedGy = CFG.smoothingFactor * smoothedGy + (1 - CFG.smoothingFactor) * gyN;
    debug.textContent += ` | smooth: ${smoothedGx.toFixed(2)},${smoothedGy.toFixed(2)}`;

    const px = A[0]*smoothedGx + A[1]*smoothedGy + b[0];
    const py = A[2]*smoothedGx + A[3]*smoothedGy + b[1];
    debug.textContent += ` | px,py: ${px.toFixed(0)},${py.toFixed(0)}`;

    // Dead zone: only update if movement is significant (>5px)
    if(Math.abs(px - lastPx) > 5 || Math.abs(py - lastPy) > 5){
      updateCursor(px,py);
      lastPx = px; lastPy = py;
    }
    dwellDetect();
  });

  function drawDot(p){ pctx.fillStyle='#0f0'; pctx.beginPath(); pctx.arc(p.x*preview.width,p.y*preview.height,2.2,0,7); pctx.fill(); }
  function cl01(v){ return Math.max(0,Math.min(1,v)); }
  function mean2(a){ if(!a.length) return [NaN,NaN]; let sx=0,sy=0; for(const v of a){ sx+=v[0]; sy+=v[1]; } return [sx/a.length, sy/a.length]; }
  function transpose(A){const m=A.length,n=A[0].length,AT=Array.from({length:n},()=>Array(m).fill(0));for(let i=0;i<m;i++)for(let j=0;j<n;j++)AT[j][i]=A[i][j];return AT;}
  function mul(A,B){const m=A.length,n=A[0].length,p=B[0].length,C=Array.from({length:m},()=>Array(p).fill(0));for(let i=0;i<m;i++)for(let k=0;k<n;k++)for(let j=0;j<p;j++)C[i][j]+=A[i][k]*B[k][j];return C;}
  function mulVec(A,v){const m=A.length,n=A[0].length,r=Array(m).fill(0);for(let i=0;i<m;i++)for(let j=0;j<n;j++)r[i]+=A[i][j]*v[j];return r;}
  function solveGaussian(A,b){const n=A.length,M=A.map((row,i)=>row.concat([b[i]]));for(let i=0;i<n;i++){let max=i;for(let r=i+1;r<n;r++)if(Math.abs(M[r][i])>Math.abs(M[max][i]))max=r;if(Math.abs(M[max][i])<1e-9)return null;[M[i],M[max]]=[M[max],M[i]];const piv=M[i][i];for(let k=i;k<=n;k++)M[i][k]/=piv;for(let r=0;r<n;r++)if(r!==i){const f=M[r][i];for(let k=i;k<=n;k++)M[r][k]-=f*M[i][k];}}return M.map(row=>row[n]);}
  function lsqAffine(srcPts,dstPts){
    if(!srcPts.length||srcPts.length<3) return null;
    const M=[],Z=[];
    for(let i=0;i<srcPts.length;i++){
      const[gx,gy]=srcPts[i]; const[tx,ty]=dstPts[i];
      M.push([gx,gy,0,0,1,0]); Z.push(tx);
      M.push([0,0,gx,gy,0,1]); Z.push(ty);
    }
    const Mt=transpose(M),MtM=mul(Mt,M),MtZ=mulVec(Mt,Z),p=solveGaussian(MtM,MtZ);
    return p?{A:[p[0],p[1],p[2],p[3]],b:[p[4],p[5]]}:null;
  }
})();
</script>
</body>
</html>
