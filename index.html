<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Brocha Ocular</title>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh"></script>

<style>
  html, body { margin:0; padding:0; height:100%; overflow:hidden; background:#0f1115; color:#fff; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif }
  #wrap { position:relative; width:100%; height:100vh }
  #topbar { position:absolute; top:10px; left:10px; right:10px; display:flex; gap:8px; flex-wrap:wrap; background:rgba(0,0,0,.45); padding:8px 10px; border-radius:10px; align-items:center; z-index:10000; box-shadow: 0 4px 6px rgba(0,0,0,.15) }
  .btn { appearance:none; border:0; padding:8px 14px; border-radius:10px; cursor:pointer; background:#2b2f3a; color:#fff; font-weight:600; transition: background .2s, transform .1s; }
  .btn:hover { background: #3b424f; }
  .btn:active { transform: scale(0.98); }
  .btn.primary { background:#00e676; color:#111; }
  .btn.primary:hover { background: #00c853; }
  .btn.warn { background:#ff5252; }
  .btn.warn:hover { background: #e04545; }
  .btn.special { background:#38bdf8; color:#111; }
  .btn.special:hover { background:#0ea5e9; }
  .sp { margin-left:auto; font:12px/1.2 monospace; opacity:.9 }
  #stage { position:absolute; inset:62px 10px 10px 10px; border-radius:10px; background:#10131a; overflow:hidden; box-shadow: 0 4px 6px rgba(0,0,0,.15); }
  #canvas { position:absolute; inset:0; width:100%; height:100% }
  #cursor { position:absolute; width:20px; height:20px; border:3px solid rgba(255,255,255,.95); border-radius:50%; pointer-events:none; transform:translate(-50%,-50%); display:none; transition: all .05s ease-out; }
  #status { position:absolute; bottom:10px; left:10px; right:10px; display:flex; gap:10px; align-items:center; background:rgba(255,255,255,.06); padding:8px 10px; border-radius:10px; z-index:9999; box-shadow: 0 -2px 4px rgba(0,0,0,.1) }
  #modeTag { font-weight:700; background:#1f2937; padding:4px 8px; border-radius:8px }
  #marPanel { display:flex; align-items:center; gap:8px; flex:1 }
  #marBar { position:relative; height:12px; flex:1; background:#2b2f3a; border-radius:6px; overflow:hidden }
  #marFill { position:absolute; top:0; left:0; height:100%; width:0%; background:#00e676; transition: width .1s ease-out; }
  #marThr { position:absolute; top:-3px; width:2px; height:18px; background:#ff5252; left:50% }
  #marVal { min-width:140px; text-align:right; font:12px/1 monospace; opacity:.9 }
  video#rawVideo { display:none }
  #errbar { position:absolute; top:0; left:0; right:0; background:#ff3344; color:#fff; padding:6px 10px; font:12px/1.3 monospace; display:none; z-index:10001; text-align: center; }
</style>
</head>
<body>
<div id="wrap">
  <div id="topbar">
    <button id="btnStartCam" class="btn primary">1. Iniciar Cámara</button>
    <button id="btnCenterGaze" class="btn special">2. Centrar Mirada</button>
    <button id="btnCalibrate" class="btn">3. Calibrar Mirada</button>
    <button id="btnToggleMode" class="btn">4. Alternar Modo Mirada</button>
    <button id="btnStartBrush" class="btn">5. Iniciar Brocha</button>
    <button id="btnClear" class="btn warn">🧹 Limpiar</button>
    <span class="sp" id="count">pts: 0</span>
  </div>

  <div id="stage">
    <canvas id="canvas"></canvas>
    <div id="cursor"></div>
    <video id="rawVideo" playsinline autoplay muted></video>
  </div>

  <div id="status">
    <span id="modeTag">Modo: Esperando</span>
    <div id="marPanel">
      <span>Boca:</span>
      <div id="marBar"><div id="marFill"></div><div id="marThr"></div></div>
      <span id="marVal">—</span>
    </div>
  </div>
  <div id="errbar"></div>
</div>

<script>
(function(){
  // --- Estado de la aplicación ---
  let mode = 'idle'; // 'idle', 'brush'
  let isPainting = false;
  let isFaceDetected = false;
  let gazeMode = 'head'; // 'head' o 'eye'
  let calibrationPoints = { tl: null, tr: null, br: null, bl: null };
  let calibrationStep = 0;
  
  // --- Configuración ---
  const CFG = {
    brush: 15,
    mouthThr: 0.35,
    mouthHys: 0.05,
    gazeScaleHeadX: 10,
    gazeScaleHeadY: 14,
    gazeScaleEyeX: 2.5,
    gazeScaleEyeY: 3,
    invertGazeY: true,
    gazeSmoothingAlpha: 0.25,
    gazeMaxSpeed: 0.1
  };

  // --- Elementos del DOM ---
  const errbar = document.getElementById('errbar');
  const stageEl = document.getElementById('stage');
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const cursor = document.getElementById('cursor');
  const rawVideo = document.getElementById('rawVideo');
  const countEl = document.getElementById('count');
  const modeTag = document.getElementById('modeTag');
  const marVal = document.getElementById('marVal');
  const marFill = document.getElementById('marFill');
  const marThr = document.getElementById('marThr');
  
  // --- Botones ---
  const btnStartCam = document.getElementById('btnStartCam');
  const btnCenterGaze = document.getElementById('btnCenterGaze');
  const btnCalibrate = document.getElementById('btnCalibrate');
  const btnToggleMode = document.getElementById('btnToggleMode');
  const btnStartBrush = document.getElementById('btnStartBrush');
  const btnClear = document.getElementById('btnClear');

  // --- Señales y datos ---
  let W, H;
  let irisN = {x: null, y: null};
  let marEma = null;
  let lastPoint = null;
  let drawingPoints = [];
  let gazeCenter = { x: 0.5, y: 0.5 };
  let smoothedGaze = { x: 0.5, y: 0.5 };

  // --- Funciones de Utilidad ---
  function showErr(msg) { errbar.textContent = `⚠️ ${msg}`; errbar.style.display = 'block'; }
  function showInfo(msg) { errbar.textContent = `ℹ️ ${msg}`; errbar.style.display = 'block'; setTimeout(() => errbar.style.display = 'none', 3000); }
  function dist(a, b) { return Math.hypot(a.x - b.x, a.y - b.y); }

  // --- Inicialización y Redimensionamiento ---
  function resize() {
    const dpr = window.devicePixelRatio || 1;
    const r = stageEl.getBoundingClientRect();
    W = r.width; H = r.height;
    canvas.width = Math.floor(W * dpr); canvas.height = Math.floor(H * dpr);
    canvas.style.width = W + 'px'; canvas.style.height = H + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener('resize', resize);
  resize();

  // --- Lógica del Gesto de la Boca (MAR) ---
  function processMouth(landmarks) {
    const mouthH = dist(landmarks[13], landmarks[14]);
    const mouthW = dist(landmarks[61], landmarks[291]);
    const marRaw = mouthH / (mouthW + 1e-6);
    marEma = marEma === null ? marRaw : 0.3 * marRaw + 0.7 * marEma;
    
    const marUi = Math.min(0.8, marEma);
    marVal.textContent = `Apertura: ${marEma.toFixed(3)}`;
    marFill.style.width = `${(marUi / 0.8) * 100}%`;
    marThr.style.left = `${(CFG.mouthThr / 0.8) * 100}%`;
    
    const openThr = CFG.mouthThr + CFG.mouthHys;
    const closeThr = CFG.mouthThr - CFG.mouthHys;
    isPainting = isPainting ? (marEma > closeThr) : (marEma > openThr);
  }

  // --- Lógica de la Mirada (Iris) ---
  function processGaze(landmarks) {
    const rIris = landmarks[468], lIris = landmarks[473];
    const rEyeL = landmarks[133], rEyeR = landmarks[33];
    const rEyeT = landmarks[159], rEyeB = landmarks[145];
    const lEyeL = landmarks[362], lEyeR = landmarks[263];
    const lEyeT = landmarks[386], lEyeB = landmarks[374];

    const rEyeW = dist(rEyeL, rEyeR);
    const rEyeH = dist(rEyeT, rEyeB);
    const lEyeW = dist(lEyeL, lEyeR);
    const lEyeH = dist(lEyeT, lEyeB);

    if (rEyeW > 0 && lEyeW > 0 && rEyeH > 0 && lEyeH > 0) {
        const rNormX = (rIris.x - rEyeL.x) / rEyeW;
        const lNormX = (lIris.x - lEyeL.x) / lEyeW;
        irisN.x = (rNormX + lNormX) / 2;

        const rNormY = (rIris.y - rEyeT.y) / rEyeH;
        const lNormY = (lIris.y - lEyeT.y) / lEyeH;
        irisN.y = (rNormY + lNormY) / 2;
    }
  }

  // --- Bucle Principal de Detección ---
  const faceMesh = new FaceMesh({ locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}` });
  faceMesh.setOptions({ maxNumFaces: 1, refineLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
  
  faceMesh.onResults(results => {
    if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
      if (!isFaceDetected) {
          isFaceDetected = true;
          showInfo("✅ Rostro detectado. ¡Ahora centra tu mirada!");
          btnCenterGaze.disabled = false;
          btnCalibrate.disabled = false;
          btnToggleMode.disabled = false;
          btnStartBrush.disabled = false;
      }
      const lm = results.multiFaceLandmarks[0];
      processMouth(lm);
      processGaze(lm);

      let deltaX, deltaY;
      let scaleX, scaleY;
      
      // Aplicar lógica según el modo de mirada
      if (gazeMode === 'head') {
        scaleX = CFG.gazeScaleHeadX;
        scaleY = CFG.gazeScaleHeadY;
        deltaX = (irisN.x - gazeCenter.x) * scaleX;
        deltaY = (irisN.y - gazeCenter.y) * scaleY * (CFG.invertGazeY ? -1 : 1);
      } else { // modo 'eye'
        scaleX = CFG.gazeScaleEyeX;
        scaleY = CFG.gazeScaleEyeY;
        // Invertir el movimiento
        deltaX = (gazeCenter.x - irisN.x) * scaleX;
        deltaY = (gazeCenter.y - irisN.y) * scaleY * (CFG.invertGazeY ? -1 : 1);
      }
      
      const targetX = (W / 2) + (deltaX * W);
      const targetY = (H / 2) + (deltaY * H);
      
      if (mode !== 'idle' && smoothedGaze.x === 0.5) {
          smoothedGaze.x = targetX;
          smoothedGaze.y = targetY;
      } else {
          smoothedGaze.x = smoothedGaze.x * (1 - CFG.gazeSmoothingAlpha) + targetX * CFG.gazeSmoothingAlpha;
          smoothedGaze.y = smoothedGaze.y * (1 - CFG.gazeSmoothingAlpha) + targetY * CFG.gazeSmoothingAlpha;
      }

      const dx_norm = (smoothedGaze.x / W) - (cursor.offsetLeft / W);
      const dy_norm = (smoothedGaze.y / H) - (cursor.offsetTop / H);
      const dist_norm = Math.sqrt(dx_norm * dx_norm + dy_norm * dy_norm);

      if (dist_norm > CFG.gazeMaxSpeed) {
          const ratio = CFG.gazeMaxSpeed / dist_norm;
          smoothedGaze.x = (cursor.offsetLeft) + (dx_norm * ratio * W);
          smoothedGaze.y = (cursor.offsetTop) + (dy_norm * ratio * H);
      }

      const x = Math.max(0, Math.min(W, smoothedGaze.x));
      const y = Math.max(0, Math.min(H, smoothedGaze.y));

      if (mode !== 'idle') {
        cursor.style.display = 'block';
        cursor.style.left = `${x}px`;
        cursor.style.top = `${y}px`;
      }

      if (mode === 'brush' && isPainting) {
        if (lastPoint) {
          ctx.strokeStyle = 'rgba(0,200,255,.95)'; ctx.lineWidth = CFG.brush; ctx.lineJoin = 'round'; ctx.lineCap = 'round';
          ctx.beginPath();
          ctx.moveTo(lastPoint.x, lastPoint.y);
          ctx.lineTo(x, y);
          ctx.stroke();
          drawingPoints.push({ x, y });
          countEl.textContent = `pts: ${drawingPoints.length}`;
        }
        lastPoint = { x, y };
      } else {
        lastPoint = null;
      }
      
    } else {
      isFaceDetected = false;
      cursor.style.display = 'none';
      btnCenterGaze.disabled = true;
      btnCalibrate.disabled = true;
      btnToggleMode.disabled = true;
      btnStartBrush.disabled = true;
      showErr("❌ No se detecta tu rostro. Acércate a la cámara.");
    }
  });

  async function startCamera() {
    if (rawVideo.srcObject) return;
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720 } });
      rawVideo.srcObject = stream;
      await rawVideo.play();
      showInfo('Cámara iniciada.');
      requestAnimationFrame(faceLoop);
    } catch (e) {
      showErr(`No se pudo acceder a la cámara: ${e.message}`);
    }
  }

  async function faceLoop() {
    if (rawVideo.readyState >= 2) {
      await faceMesh.send({ image: rawVideo });
    }
    requestAnimationFrame(faceLoop);
  }

  function centerGaze() {
      if (!isFaceDetected || irisN.x === null) {
          showErr("Aún no se detecta tu mirada. Espera un segundo.");
          return;
      }
      gazeCenter.x = irisN.x;
      gazeCenter.y = irisN.y;
      smoothedGaze.x = W / 2;
      smoothedGaze.y = H / 2;
      showInfo("🎯 Mirada centrada. ¡Ya puedes calibrar!");
  }
  
  // --- Lógica de Calibración ---
  function calibrateGaze() {
    calibrationStep = 0;
    showInfo("Comenzando calibración. Mira la esquina superior izquierda (↑↖️) y haz clic en el botón.");
  }

  function processCalibration() {
    if (calibrationStep === 0) {
      calibrationPoints.tl = {...irisN};
      calibrationStep = 1;
      showInfo("Ahora mira la esquina superior derecha (↗️) y haz clic.");
    } else if (calibrationStep === 1) {
      calibrationPoints.tr = {...irisN};
      calibrationStep = 2;
      showInfo("Ahora mira la esquina inferior derecha (↘️) y haz clic.");
    } else if (calibrationStep === 2) {
      calibrationPoints.br = {...irisN};
      calibrationStep = 3;
      showInfo("Ahora mira la esquina inferior izquierda (↙️) y haz clic.");
    } else if (calibrationStep === 3) {
      calibrationPoints.bl = {...irisN};
      calibrationStep = 0;
      calculateGazeScales();
      showInfo("🎉 ¡Calibración completa! Ya puedes iniciar la brocha.");
    }
  }

  function calculateGazeScales() {
    const minX = Math.min(calibrationPoints.tl.x, calibrationPoints.bl.x, calibrationPoints.tr.x, calibrationPoints.br.x);
    const maxX = Math.max(calibrationPoints.tl.x, calibrationPoints.bl.x, calibrationPoints.tr.x, calibrationPoints.br.x);
    const minY = Math.min(calibrationPoints.tl.y, calibrationPoints.tr.y, calibrationPoints.br.y, calibrationPoints.bl.y);
    const maxY = Math.max(calibrationPoints.tl.y, calibrationPoints.tr.y, calibrationPoints.br.y, calibrationPoints.bl.y);

    const rangeX = maxX - minX;
    const rangeY = maxY - minY;

    if (rangeX > 0 && rangeY > 0) {
      CFG.gazeScaleHeadX = 1 / rangeX;
      CFG.gazeScaleHeadY = 1 / rangeY;
      
      CFG.gazeScaleEyeX = (1 / rangeX) * 0.25;
      CFG.gazeScaleEyeY = (1 / rangeY) * 0.25;
      
      gazeCenter.x = minX + rangeX / 2;
      gazeCenter.y = minY + rangeY / 2;
    }
  }

  function toggleGazeMode() {
    if (gazeMode === 'head') {
        gazeMode = 'eye';
        btnToggleMode.textContent = "4. Modo Ojo";
        CFG.invertGazeY = false;
        showInfo("Modo Ojo activado. Fija tu cabeza y mueve solo tus ojos.");
    } else {
        gazeMode = 'head';
        btnToggleMode.textContent = "4. Modo Cabeza";
        CFG.invertGazeY = true;
        showInfo("Modo Cabeza activado. Mueve tu cabeza para navegar.");
    }
  }

  // --- Eventos de Botones ---
  btnStartCam.onclick = startCamera;
  btnCenterGaze.onclick = centerGaze;
  btnCalibrate.onclick = processCalibration;
  btnToggleMode.onclick = toggleGazeMode;
  btnStartBrush.onclick = () => {
    mode = 'brush';
    modeTag.textContent = 'Modo: Brocha';
    showInfo('¡Mueve tus ojos para dibujar! Abre la boca para activar la brocha.');
  };
  btnClear.onclick = () => {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawingPoints = [];
    countEl.textContent = 'pts: 0';
  };

  // Deshabilitar botones al inicio
  btnCenterGaze.disabled = true;
  btnCalibrate.disabled = true;
  btnToggleMode.disabled = true;
  btnStartBrush.disabled = true;

})();
</script>
</body>
</html>
