<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Brocha Ocular</title>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh"></script>

<style>
  html, body { margin:0; padding:0; height:100%; overflow:hidden; background:#0f1115; color:#fff; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif }
  #wrap { position:relative; width:100%; height:100vh }
  #topbar { position:absolute; top:10px; left:10px; right:10px; display:flex; gap:8px; flex-wrap:wrap; background:rgba(0,0,0,.45); padding:8px 10px; border-radius:10px; align-items:center; z-index:10000; box-shadow: 0 4px 6px rgba(0,0,0,.15) }
  .btn { appearance:none; border:0; padding:8px 14px; border-radius:10px; cursor:pointer; background:#2b2f3a; color:#fff; font-weight:600; transition: background .2s, transform .1s; }
  .btn:hover { background: #3b424f; }
  .btn:active { transform: scale(0.98); }
  .btn.primary { background:#00e676; color:#111; }
  .btn.primary:hover { background: #00c853; }
  .btn.warn { background:#ff5252; }
  .btn.warn:hover { background: #e04545; }
  .sp { margin-left:auto; font:12px/1.2 monospace; opacity:.9 }
  #stage { position:absolute; inset:62px 10px 10px 10px; border-radius:10px; background:#10131a; overflow:hidden; box-shadow: 0 4px 6px rgba(0,0,0,.15); }
  #canvas { position:absolute; inset:0; width:100%; height:100% }
  #cursor { position:absolute; width:20px; height:20px; border:3px solid rgba(255,255,255,.95); border-radius:50%; pointer-events:none; transform:translate(-50%,-50%); display:none; transition: all .05s ease-out; }
  #status { position:absolute; bottom:10px; left:10px; right:10px; display:flex; gap:10px; align-items:center; background:rgba(255,255,255,.06); padding:8px 10px; border-radius:10px; z-index:9999; box-shadow: 0 -2px 4px rgba(0,0,0,.1) }
  #modeTag { font-weight:700; background:#1f2937; padding:4px 8px; border-radius:8px }
  #marPanel { display:flex; align-items:center; gap:8px; flex:1 }
  #marBar { position:relative; height:12px; flex:1; background:#2b2f3a; border-radius:6px; overflow:hidden }
  #marFill { position:absolute; top:0; left:0; height:100%; width:0%; background:#00e676; transition: width .1s ease-out; }
  #marThr { position:absolute; top:-3px; width:2px; height:18px; background:#ff5252; left:50% }
  #marVal { min-width:140px; text-align:right; font:12px/1 monospace; opacity:.9 }
  #dbg { position:absolute; right:10px; bottom:10px; background:rgba(0,0,0,.55); padding:6px 8px; border-radius:8px; font:12px/1.2 monospace; opacity: .8 }
  video#rawVideo { display:none }
  #errbar { position:absolute; top:0; left:0; right:0; background:#ff3344; color:#100; padding:6px 10px; font:12px/1.3 monospace; display:none; z-index:10001; text-align: center; }
  .calib-step-ui { position:absolute; inset:0; display:flex; flex-direction:column; justify-content:center; align-items:center; background:rgba(0,0,0,0.7); z-index:100; }
  .calib-step-ui h2 { margin:0; padding:10px; font-size: 2em; }
  .calib-step-ui p { margin:5px 0 20px; font-size: 1.2em; max-width: 600px; text-align: center; }
  .calib-target { position:absolute; width:18px; height:18px; border-radius:50%; background:#00e676; box-shadow:0 0 0 6px rgba(0,230,118,.2); transform:translate(-50%,-50%); pointer-events:auto; cursor:crosshair; transition: all .3s }
  .calib-target.wait { background:#fbbf24; box-shadow:0 0 0 6px rgba(251,191,36,.25); }
  .calib-target.done { background:#22d3ee; box-shadow:0 0 0 6px rgba(34,211,238,.25); }
</style>
</head>
<body>
<div id="wrap">
  <div id="topbar">
    <button id="testCam" class="btn primary">Iniciar Cámara</button>
    <button id="btnCalibrate" class="btn">Calibrar Límites</button>
    <button id="btnStart" class="btn">Iniciar Brocha</button>
    <button id="btnClear" class="btn warn">🧹 Limpiar</button>
    <span class="sp" id="count">pts: 0</span>
  </div>

  <div id="stage">
    <canvas id="canvas"></canvas>
    <div id="cursor"></div>
    <div id="calibUI" class="calib-step-ui" style="display: none;">
      <h2 id="calibTitle"></h2>
      <p id="calibDescription"></p>
    </div>
    <div id="dbg" style="display:none"></div>
    <video id="rawVideo" playsinline autoplay muted></video>
  </div>

  <div id="status">
    <span id="modeTag">Modo: Esperando</span>
    <div id="marPanel">
      <span>MAR:</span>
      <div id="marBar"><div id="marFill"></div><div id="marThr"></div></div>
      <span id="marVal">—</span>
    </div>
  </div>

  <div id="errbar"></div>
</div>

<script>
(function(){
  // --- Estado de la aplicación ---
  let mode = 'idle'; // 'idle', 'calibrating_limits', 'brush'
  let isPainting = false;
  let isFaceDetected = false;
  
  // --- Configuración (ajustable) ---
  const CFG = {
    brush: 12,
    mouthThr: 0.28,
    mouthHys: 0.05,
    marMedianN: 5,
    marEmaAlpha: 0.30,
    // Ganancia y Offset para el mapeo
    offset: {x: 0, y: 0},
    scale: {x: 1, y: 1},
    invertY: true,
    // Margen de calibración en % del viewport
    calib_margin_x: 0.1,
    calib_margin_y: 0.1,
    // Control de suavizado y velocidad
    gazeSmoothingAlpha: 0.25, // Mayor valor = menos suavizado (más rápido)
    gazeMaxSpeed: 0.1 // Velocidad máxima del cursor (normalizada 0-1)
  };

  // --- Elementos del DOM ---
  const errbar = document.getElementById('errbar');
  const stageEl = document.getElementById('stage');
  const canvas = document.getElementById('canvas'); const ctx = canvas.getContext('2d');
  const cursor = document.getElementById('cursor');
  const rawVideo = document.getElementById('rawVideo');
  const countEl = document.getElementById('count');
  const modeTag = document.getElementById('modeTag');
  const marVal = document.getElementById('marVal');
  const marFill = document.getElementById('marFill');
  const marThr = document.getElementById('marThr');
  const calibUI = document.getElementById('calibUI');
  const calibTitle = document.getElementById('calibTitle');
  const calibDescription = document.getElementById('calibDescription');
  const btnCalibrate = document.getElementById('btnCalibrate');
  const btnStart = document.getElementById('btnStart');

  // --- Señales y datos ---
  let W, H;
  let irisN = {x: null, y: null};
  let marEma = null;
  let lastPoint = null;
  let drawingPoints = [];
  let calibrationPoints = [];
  let smoothedGaze = { x: 0.5, y: 0.5 };

  // --- Funciones de Utilidad ---
  function showErr(msg) { errbar.textContent = `⚠️ ${msg}`; errbar.style.display = 'block'; }
  function showInfo(msg) { errbar.textContent = `ℹ️ ${msg}`; errbar.style.display = 'block'; }
  function hideErr() { errbar.style.display = 'none'; }
  function median(arr) { if(!arr.length) return NaN; const a=[...arr].sort((x,y)=>x-y), m=Math.floor(a.length/2); return a.length%2 ? a[m] : (a[m-1]+a[m])/2; }
  function dist2(a, b) { return Math.hypot(a.x - b.x, a.y - b.y); }
  function sleep(ms) { return new Promise(res => setTimeout(res, ms)); }
  function saveCalib() {
      const data = { offset: CFG.offset, scale: CFG.scale };
      localStorage.setItem('calibData', JSON.stringify(data));
  }
  function loadCalib() {
      try {
          const data = JSON.parse(localStorage.getItem('calibData'));
          if (data) {
              CFG.offset = data.offset;
              CFG.scale = data.scale;
              showInfo("✅ Calibración guardada cargada.");
              return true;
          }
      } catch (e) {
          console.error("Error loading calibration:", e);
      }
      return false;
  }

  // --- Inicialización y Redimensionamiento ---
  function resize() {
    const dpr = window.devicePixelRatio || 1;
    const r = stageEl.getBoundingClientRect();
    W = r.width; H = r.height;
    canvas.width = Math.floor(W * dpr); canvas.height = Math.floor(H * dpr);
    canvas.style.width = W + 'px'; canvas.style.height = H + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener('resize', resize); resize();

  // --- Lógica del Gesto de la Boca (MAR) ---
  const marHist = [];
  function processMouth(landmarks) {
    const mouthH = dist2(landmarks[13], landmarks[14]);
    const mouthW = dist2(landmarks[61], landmarks[291]);
    const marRaw = mouthH / Math.max(1e-6, mouthW);
    marHist.push(marRaw);
    if (marHist.length > CFG.marMedianN) marHist.shift();
    const med = median(marHist);
    marEma = marEma == null ? med : CFG.marEmaAlpha * med + (1 - CFG.marEmaAlpha) * marEma;
    const marUi = Math.max(0, Math.min(0.8, marEma));
    marVal.textContent = `raw: ${marRaw.toFixed(3)} | filt: ${marEma.toFixed(3)}`;
    marFill.style.width = (marUi / 0.8 * 100).toFixed(0) + '%';
    marThr.style.left = (Math.max(0, Math.min(1, CFG.mouthThr / 0.8)) * 100).toFixed(0) + '%';
    
    const openThr = CFG.mouthThr + CFG.mouthHys;
    const closeThr = CFG.mouthThr - CFG.mouthHys;
    isPainting = isPainting ? (marEma > closeThr) : (marEma > openThr);
  }

  // --- Lógica de la Mirada (Iris) ---
  function processGaze(landmarks) {
    const avg = (idxs) => idxs.reduce((s, i) => ({ x: s.x + landmarks[i].x, y: s.y + landmarks[i].y }), { x: 0, y: 0 });
    const rC = avg([468, 469, 470, 471]); rC.x /= 4; rC.y /= 4;
    const lC = avg([473, 474, 475, 476]); lC.x /= 4; lC.y /= 4;

    const R_L = landmarks[133], R_R = landmarks[33];
    const L_L = landmarks[362], L_R = landmarks[263];

    const rW = Math.abs(R_R.x - R_L.x), lW = Math.abs(L_R.x - L_L.x);
    
    let irisX_norm;
    let irisY_norm;

    if (rW > 0 && lW > 0) {
        let rx_norm = (rC.x - R_L.x) / rW;
        let lx_norm = (lC.x - L_L.x) / lW;
        irisX_norm = (rx_norm + lx_norm) / 2;
    } else {
        irisX_norm = 0.5;
    }

    const R_T = landmarks[159], R_B = landmarks[145];
    const L_T = landmarks[386], L_B = landmarks[374];
    const rH = Math.abs(R_B.y - R_T.y), lH = Math.abs(L_B.y - L_T.y);

    if (rH > 0 && lH > 0) {
        let ry_norm = (rC.y - R_T.y) / rH;
        let ly_norm = (lC.y - L_T.y) / lH;
        irisY_norm = (ry_norm + ly_norm) / 2;
    } else {
        irisY_norm = 0.5;
    }
    
    irisN.x = irisX_norm;
    irisN.y = irisY_norm;
  }

  // --- Detección de Rostros y Bucle Principal ---
  const faceMesh = new FaceMesh({ locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}` });
  faceMesh.setOptions({ maxNumFaces: 1, refineLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
  
  faceMesh.onResults(results => {
    if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
      if (!isFaceDetected) {
          isFaceDetected = true;
          showInfo("✅ Rostro detectado. ¡Ya puedes calibrar!");
          btnCalibrate.disabled = false;
          btnStart.disabled = false;
      }
      const lm = results.multiFaceLandmarks[0];
      processMouth(lm);
      processGaze(lm);

      // Mapeo afín después de la calibración
      let px_mapped = (irisN.x - CFG.offset.x) * CFG.scale.x;
      let py_mapped = (irisN.y - CFG.offset.y) * CFG.scale.y;

      // Invertir el eje Y si es necesario
      if (CFG.invertY) {
        py_mapped = 1 - py_mapped;
      }
      
      // Aplicar suavizado (filtro de una pasada)
      if (mode !== 'idle' && smoothedGaze.x === 0.5) { 
          smoothedGaze.x = px_mapped;
          smoothedGaze.y = py_mapped;
      } else {
          smoothedGaze.x = smoothedGaze.x * (1 - CFG.gazeSmoothingAlpha) + px_mapped * CFG.gazeSmoothingAlpha;
          smoothedGaze.y = smoothedGaze.y * (1 - CFG.gazeSmoothingAlpha) + py_mapped * CFG.gazeSmoothingAlpha;
      }

      // Limitar la velocidad
      const dx_norm = smoothedGaze.x - (cursor.offsetLeft / W);
      const dy_norm = smoothedGaze.y - (cursor.offsetTop / H);
      const dist_norm = Math.sqrt(dx_norm * dx_norm + dy_norm * dy_norm);

      if (dist_norm > CFG.gazeMaxSpeed) {
          const ratio = CFG.gazeMaxSpeed / dist_norm;
          smoothedGaze.x = (cursor.offsetLeft / W) + dx_norm * ratio;
          smoothedGaze.y = (cursor.offsetTop / H) + dy_norm * ratio;
      }

      let px = smoothedGaze.x * W;
      let py = smoothedGaze.y * H;

      const x = Math.max(0, Math.min(W, px));
      const y = Math.max(0, Math.min(H, py));

      if (mode !== 'idle') {
        cursor.style.display = 'block';
        cursor.style.left = x + 'px';
        cursor.style.top = y + 'px';
      }

      if (mode === 'brush' && isPainting) {
        if (lastPoint) {
          ctx.strokeStyle = 'rgba(0,200,255,.95)'; ctx.lineWidth = CFG.brush; ctx.lineJoin = 'round'; ctx.lineCap = 'round';
          ctx.beginPath();
          ctx.moveTo(lastPoint.x, lastPoint.y);
          ctx.lineTo(x, y);
          ctx.stroke();
          drawingPoints.push({ x: x, y: y, mar: marEma, t: Date.now() });
          countEl.textContent = `pts: ${drawingPoints.length}`;
        }
        lastPoint = { x, y };
      } else {
        lastPoint = null;
      }
      
    } else {
      isFaceDetected = false;
      cursor.style.display = 'none';
      btnCalibrate.disabled = true;
      btnStart.disabled = true;
      showErr("❌ No se detecta tu rostro. Acércate a la cámara.");
    }
  });

  async function startCamera() {
    if (rawVideo.srcObject) return;
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ video: { width: { ideal:1280 }, height: { ideal:720 }, facingMode:"user" } });
      rawVideo.srcObject = stream;
      await rawVideo.play();
      hideErr();
      requestAnimationFrame(faceLoop);
      if (!loadCalib()) {
        showInfo('Cámara lista. Por favor, calibra tu mirada.');
      }
    } catch (e) {
      showErr(`No se pudo acceder a la cámara. ${e.name}: ${e.message}`);
    }
  }

  async function faceLoop() {
    if (rawVideo.readyState >= 2 && !rawVideo.paused && !rawVideo.ended) {
      await faceMesh.send({ image: rawVideo });
    }
    requestAnimationFrame(faceLoop);
  }

  // --- Funciones de Calibración ---
  function showCalibUI(title, description) {
    calibUI.style.display = 'flex';
    calibTitle.textContent = title;
    calibDescription.textContent = description;
  }

  function hideCalibUI() {
    calibUI.style.display = 'none';
  }
  
  async function startCalibLimits() {
    if (!isFaceDetected) {
      showErr('No se detecta tu rostro. Por favor, asegúrate de que la cámara esté activa.');
      return;
    }
    
    // Generar 9 puntos de calibración responsivos
    calibrationPoints = [];
    const marginX = W * CFG.calib_margin_x;
    const marginY = H * CFG.calib_margin_y;
    const stepX = (W - 2 * marginX) / 2;
    const stepY = (H - 2 * marginY) / 2;

    for (let i = 0; i < 3; i++) {
        for (let j = 0; j < 3; j++) {
            const px = marginX + j * stepX;
            const py = marginY + i * stepY;
            calibrationPoints.push({ x: px, y: py, sample: null, el: null });
        }
    }

    mode = 'calibrating_limits';
    modeTag.textContent = 'Modo: Calibrando';
    
    showInfo("Iniciando calibración de límites...");
    await sleep(1000);

    for (const point of calibrationPoints) {
        showCalibUI("Calibración en Progreso", "Mira el punto azul y haz clic.");
        
        const el = document.createElement('div');
        el.className = 'calib-target';
        el.style.left = point.x + 'px';
        el.style.top = point.y + 'px';
        calibUI.appendChild(el);
        point.el = el;

        await new Promise(res => {
            el.onclick = () => {
                point.sample = {x: irisN.x, y: irisN.y};
                el.style.background = '#00e676';
                res();
            };
        });
        await sleep(500);
        el.remove();
    }
    
    hideCalibUI();
    calculateAffineMapping();
    saveCalib();
    showInfo("✅ Calibración completa. Puedes iniciar la brocha.");
    btnStart.disabled = false;
  }
  
  function calculateAffineMapping() {
    if (!isFaceDetected || calibrationPoints.some(p => p.sample === null)) {
      showErr('Faltan puntos de calibración. Por favor, recalibra.');
      return;
    }
    
    const src = calibrationPoints.map(p => [p.sample.x, p.sample.y]);
    const dst = calibrationPoints.map(p => [p.x / W, p.y / H]); // Normalizar a 0-1
    
    const meanSrc = [src.reduce((sum, p) => sum + p[0], 0) / src.length, src.reduce((sum, p) => sum + p[1], 0) / src.length];
    const meanDst = [dst.reduce((sum, p) => sum + p[0], 0) / dst.length, dst.reduce((sum, p) => sum + p[1], 0) / dst.length];
    
    CFG.offset.x = meanSrc[0];
    CFG.offset.y = meanSrc[1];
    
    const rangeX = Math.max(...src.map(p => p[0])) - Math.min(...src.map(p => p[0]));
    const rangeY = Math.max(...src.map(p => p[1])) - Math.min(...src.map(p => p[1]));
    
    if (rangeX > 0) CFG.scale.x = 1 / rangeX;
    if (rangeY > 0) CFG.scale.y = 1 / rangeY;

    // Invertir el eje X si el movimiento es al revés
    const left_sample_x = calibrationPoints.find(p => Math.round(p.x) === Math.round(W * CFG.calib_margin_x)).sample.x;
    const right_sample_x = calibrationPoints.find(p => Math.round(p.x) === Math.round(W * (1 - CFG.calib_margin_x))).sample.x;
    if (left_sample_x > right_sample_x) {
        CFG.scale.x *= -1;
    }
  }

  // --- Eventos de Botones ---
  document.getElementById('testCam').onclick = startCamera;
  document.getElementById('btnCalibrate').onclick = startCalibLimits;
  document.getElementById('btnStart').onclick = () => {
    mode = 'brush';
    modeTag.textContent = 'Modo: Brocha';
    showInfo('¡Mueve tus ojos para dibujar! Abre la boca para activar la brocha.');
  };
  document.getElementById('btnClear').onclick = () => {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawingPoints = [];
    countEl.textContent = 'pts: 0';
  };

})();
</script>
</body>
</html>
